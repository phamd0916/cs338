Doug Pham
file-formats.txt

-----BEGIN RSA PRIVATE KEY-----
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
-----END RSA PRIVATE KEY-----

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC+b51+5eazti4lbLpSkcSq45Gk1h8vVj7UN9MJMkaDX8CZN0FmbAjePYNa4WkHAekuw6GzK58j/mf2Mmyp5jrc2T68XRiR3JtzA2wxdVBiosMV6nJVcSkY/Qu507HheixY5Ol0qBaXbF/kScT5D/0Bz+uJwYdLoMu4bjncpvkxLKtFuQ5grpw3LOlzjIfmy7/Huxs4PzgYdg5A6fw7Cq4DdFvEmNzXUGxMFPktpvbgPHkBUdMp/oRqDd6++Rr31BCo3ztPXWiM7NBKfaQJl5PX84ldFRvzdDEwEbv/Pdc+cc6ljNykL9osqanWtMAqbYHlh0qPeeRDwLbq3jUwCyuC2pxr3k2KsmgtLc4v+/HBOlsFjpH3g+DSBy6CZfvtVG1qFfe8bR/u3bD+ANUrzRygZg/GEHRs4DOlK1j6vgtYxY4vdYgkalQpxcqK6cEyCIYIAfj/fsxH04fGJiJnXxeTlGJDo/yDkrRIAu9PvkU67nP6YgCnkS2FgGevXiTTbaU= phamd@mantis

-----Private-----
3. We would expect to see the following in the private key: the version, modulus, publicExponent, privateExponent, prime1 (p), prime2 (q), exponent1 (d mod (p - 1)), exponent2 (d mod (q - 1)), coefficient (q^(-1) mod p), and an optional otherPrimesInfo.

4. To decode the private key, I used Michael Holtstrom's ASN.1 decoder and pasted the private key I created earlier. To format it correctly I deleted the PEM header and footer so that all that is in the input is just the base64 text.

5. 
INTEGER 0x00 (0 decimal)
This integer corresponds to the version which has the value of 0. The DER encoding for this integer is 02 01 and begins at an offset of 4. For the DER encoding of this integer, we look at the first byte 02 and convert this into binary which is 00000010 and we take the first leftmost two bits which is the tag class and here it is universal. Then the next bit shows it is the primitive type. The remaining bits represent what type it is and since it equals 2, that means it is an INTEGER type. Looking at the next byte, 01, if we convert this into binary we get 00000001. We take the first leftmost bit and this represents how many octets of length it is. Since it is 0, then it is only 1 octet of length and the remaining bits show the value of the length which here it is 1 byte. The next byte which is the last byte for this integer is the value of it which is 00 or 0 in decimal.

   INTEGER 0x00be6f9d7ee5e6b3b62e256cba5291c4aae391a4d61f2f563ed437d3093246835fc0993741666c08de3d835ae1690701e92ec3a1b32b9f23fe67f6326ca9e63adcd93ebc5d1891dc9b73036c31755062a2c315ea7255712918fd0bb9d3b1e17a2c58e4e974a816976c5fe449c4f90ffd01cfeb89c1874ba0cbb86e39dca6f9312cab45b90e60ae9c372ce9738c87e6cbbfc7bb1b383f3818760e40e9fc3b0aae03745bc498dcd7506c4c14f92da6f6e03c790151d329fe846a0ddebef91af7d410a8df3b4f5d688cecd04a7da4099793d7f3895d151bf374313011bbff3dd73e71cea58cdca42fda2ca9a9d6b4c02a6d81e5874a8f79e443c0b6eade35300b2b82da9c6bde4d8ab2682d2dce2ffbf1c13a5b058e91f783e0d2072e8265fbed546d6a15f7bc6d1feeddb0fe00d52bcd1ca0660fc610746ce033a52b58fabe0b58c58e2f7588246a5429c5ca8ae9c13208860801f8ff7ecc47d387c62622675f1793946243a3fc8392b44802ef4fbe453aee73fa6200a7912d858067af5e24d36da5

This integer corresponds to the modulus variable which has a value as displayed in the hexadecimal above. The DER encoding for this integer is 02 82 01 81 and begins at an offset of 7 bytes. Looking at the leftmost byte, we see that it has the universal tag class with a primitive INTEGER type. Looking at the next byte the value is 82 which in binary is 10000010 and since the leftmost bit is 1 then we know the length of the sequence is 1-126 octets. Looking at the remaining bits we can determine that the length of the sequence is 2 octets long. Then looking at the next two bytes we know the exact length of the sequence is 0x181.

   INTEGER 0x010001 (65537 decimal)

This integer corresponds to the public exponent variable and has the value of 65537 in decimal. The DER encoding for this integer is 02 03 and begins at an offset of 396 bytes. Looking at the leftmost byte, we can tell that it has the universal tag class with a primitive INTEGER type. Looking at the next byte which has a value of 03, which in binary is 00000011 so we know that it is one octet in length and the length of the sequence is 3 bytes.

   INTEGER 0x00a4aba346bdc9d6106caad3eff1c2368b86a8c41e9b6cb56932dcead182f5d2581414e8e0d68e08c513efe7c00eaf8e8972749bf87079f607e121d4cc7dc5a5949f0e4e9739cdb7337c2ab37db8f1bfb8fa7492fc36c1d945d05a395fc2eb3457f0ae50e91d081bfc0c973ceae46b5cde1a4a941e12bde4d7042ddc3edeeb90080e3a0621569ce65c17abeeccd01f54840b53d1dfbb5ae85bfd4b4889610c85185b9f96ca8ffc67809df16cde7b07f3329777faa75c22c7a16548fd5e2e61aaaf14337bce2818a1a306d7b1b5511168619e54668b0ac4e3019cabf6d2482b362f09f613f0e439d14b52e84726becac4d3fe4655694344b159ff4d23d53244e0409471936c62385d356b86b814a69ca1d15459f644be6bf9ccb4df25b084185e194e30c647edaea0516d4fc7450ffd33b27fc6c6aa384a03ed152d5e51c08328bb24f740805c12124706a39b0851d8206530702e7d733fdad7c09cbf33e98d8eb7eacda5bcf153bdcf4dcad3a15298555f9065d9c334374ee721a4ed1174269d69

This integer corresponds to the private exponent variable and has the value as displayed in the hexadecimal above. The DER encoding for this integer is 02 82 01 81 which begins at an offset of 401 bytes. This is the same encoding as the modulus variable INTEGER one from earlier so we know it has the universal tag class with a primitive INTEGER type. We know the sequence is two octets long and has the exact length of 0x181.

   INTEGER 0x00fb19404a797de832728c705239bc6cb9498464b2b91c04903ea78badf60cbfd5918168766405a8625d9aa22b51808c2a05ce96466a6be27e56bdb1cf762570fb5e2c7361724d16ab7e14b7f0c014f1a9c3eb1e7f392f637340c3563b0b62004fd5c2220f06581af60b2c91253fb15e41ee9468dabd94a6fb9c7aba2964fae9b8983abbc385439279528e98ede2b96b43ea9d5489400c9acb48235568ffd47cbaefcffdf55e730dd7abb72ded90e2a44afcf900e189e0c63e79652efb0c21b44b

This integer corresponds to the prime1 variable (p) and its value is the hexadecimal above. The DER encoding for this integer is 02 81 C1 which begins at an offset of 790 bytes. We see the type for this variable, which is the first byte is 02, which once again means it is a universal tag class with a primitive INTEGER type. The next byte is 81 which converts to 10000001 which means that it has a length that is 1 octet long and the length of the sequence is 0xC1.

   INTEGER 0x00c2273b0f22dbb3805a0fde4c50b7326aea11174925657d9a6bdfb718d3a6c2afa514c1a524104202f1b45c44613d794df53216732d6bb13b5c9c937244157058e652f83c245b0982a8cf25ef27d5f143bfb31d0a62199502d7e47d21381d18351f68835bc3773837b4d8b4e6122baeaf9e8d2dbc97039b831b9b4f454989d1ba18650a08de217a8db9b3d43943eba4d07d688cdfb0e5a60a84cdcb66582f4a0f4e2a3515239d012154aaf071e591c00259567ec284cf3e38b46e89365c1ecfcf

This integer corresponds to the prime2 variable (q) and its value is the hexadecimal above. The DER encoding for this integer is 02 81 C1 which begins at an offset of 986 bytes. This encoding is the same as the prime1 variable so we know it has the universal tag class with a primitive INTEGER type. The length is 1 octet long and the length of the sequence is 0xC1.

   INTEGER 0x00f74c423e56f342d95469ae41bd2d2f23391d9413552e1bec785888bfb6e18d996829bc59455f311c57b5f0db9af47096fe8b1d0392d2580a37a1b1da7230a3da5d40880e44055a3b61fc43c06f5cf139528460cfc9e13b200a7b9794a53c4ab45601518bdca2af42fd74522b0e54c0514d088b504b807908bb6f3fa37f19835053551d118e5123942b53d7980a40b53cf9772407dcb5cd4a41ecd2b48ba999827ea729261c745200c3d4affe1640b0b04dff6af7b5d4534aba428607a846158b

This integer corresponds to the exponent1 (d mod (p - 1)) variable and its value is the hexadecimal above. The DER encoding for this integer is 02 81 C1 and begins at an offset of 1182 bytes. This once again is the same encoding for this variable as previously so it has the same type and length as both prime variables.

   INTEGER 0x714b79402ce42d8bf1821f03437a93b625de514b42c245982de8bf2c829d66301ed1ccea33f034c5090c696711a350bcf81f0150b6a988238eb863a6232aab8384ebd7a528c5e2f7d6d0025fdb4c11dca9e9b8418ddb45c401fd7833414e6108e6ca1315222bd8a75125bff21d9a55f66f3c0cfb66d8191059b4b87e431a644306e73702d3b48f92525228be3def2d1ee87f70ed3b89d6e97e73a48495630b01816849cf8b179c4839e3022a447f579f47489cf19f945bc7b52a67714c3242ab

This integer corresponds to the exponent2 (d mod (q - 1)) variable and its value is the hexadecimal above. The DER encoding for this integer is 02 81 C0 and begins at an offset of 1378 bytes. This once again is similar to the previous variable but the only difference with this variable is rather than the length of the sequence being 0xC1 it is instead 0xC0.

   INTEGER 0x00cae98f1258d379995b4cf6c11459ae78faff57fc708a96ba1c99ea0543f81aac99851b8b9f7f727e45c1f14ca3008412bb6e2780be51f9df5007ff21e5d29e87e3e40747f77d88fb58b50fa5dcf6c692289cc95ddd2ea5a5ca30045e72d4eb1718a4b6ed1e2728f1534af48a2187aeb0bb6906bbf97cee8b9439c4e191a7100257cb4a78d1b6b332848202d9f07041e988e20a645dc67e92448079ba1f579de1b2c65735c4bf26331d9f25b5fd8cddbd77424cad52ffec3bd7902cc479db54af

This integer corresponds to the coefficient (q^(-1) mod p) variable and its value is the hexadecimal above. The DER encoding for this integer is 02 81 C1 and begins at an offset of 1573. This encoding is the same as the previous variables but the length of this sequence is 0xC1.

-----Public Key-----
What we would expect to see in the public key is the variables, n, the modulus, and e, the public exponent. To determine what n and e were I used this python code from this blog post by Leonardo Giordano: https://www.thedigitalcatonline.com/blog/2018/04/25/rsa-keys/
Python Code:
from Crypto.PublicKey import RSA

f = open('cs338.pem', 'r')
key = RSA.importKey(f.read())

modulus = key.n
public_exponent = key.e

print("Modulus:", modulus)
print("Public Exponent: ", public_exponent)

This gave the numbers
n (Modulus) = 4321711365538167485028818470023373237431937826992099410632815853099477359804546384783506669234475138498554534513686568740385980955255858701434166151439397005844931267467048209034696416843336334236896445972244707188763155787084469014745423829818300987324299799966816301586903564933060256613027408850566438447284162469138129270264909875446856833355774873190173177137515052501927678740503728530604402140779823918183605633845094593637241532075991313881179796907945296197618512357614017385694841220259167067170500868919659372952275319226802423394350967983411130403033676393877200328709440208071759930525996023787894150726458445237443482748245911794545742576801761250115419478033772412485986641161318136591589004982863603789074113951599470272153285800415876277101206662879941089992361236353042884059063328576478409049836692374131516552042262008149737309623410159620226697666822997323506871861615175425811890220257101047561723276709
e = 65537

We can also find these by using the hexdump command:cat cs338.pub | cut -d " " -f2 |  base64 -d | hexdump -ve '/1 "%02x "' -e '2/8 "\n"' and we can find these numbers in this hexdump as explained by the blog post as well.
This is what the hexdump outputs (I labeled where the public exponent and modulus lie):
00 00 00 07 73 73 68 2d 72 73 61 00 00 00 03 
Public exponent begins here: 01 00 01
00 00 01 81 
Modulus begins here: 00 be 6f 9d 7e e5 e6 b3 b6 2e
25 6c ba 52 91 c4 aa e3 91 a4 d6 1f 2f 56 3e d4
37 d3 09 32 46 83 5f c0 99 37 41 66 6c 08 de 3d
83 5a e1 69 07 01 e9 2e c3 a1 b3 2b 9f 23 fe 67
f6 32 6c a9 e6 3a dc d9 3e bc 5d 18 91 dc 9b 73
03 6c 31 75 50 62 a2 c3 15 ea 72 55 71 29 18 fd
0b b9 d3 b1 e1 7a 2c 58 e4 e9 74 a8 16 97 6c 5f
e4 49 c4 f9 0f fd 01 cf eb 89 c1 87 4b a0 cb b8
6e 39 dc a6 f9 31 2c ab 45 b9 0e 60 ae 9c 37 2c
e9 73 8c 87 e6 cb bf c7 bb 1b 38 3f 38 18 76 0e
40 e9 fc 3b 0a ae 03 74 5b c4 98 dc d7 50 6c 4c
14 f9 2d a6 f6 e0 3c 79 01 51 d3 29 fe 84 6a 0d
de be f9 1a f7 d4 10 a8 df 3b 4f 5d 68 8c ec d0
4a 7d a4 09 97 93 d7 f3 89 5d 15 1b f3 74 31 30
11 bb ff 3d d7 3e 71 ce a5 8c dc a4 2f da 2c a9
a9 d6 b4 c0 2a 6d 81 e5 87 4a 8f 79 e4 43 c0 b6
ea de 35 30 0b 2b 82 da 9c 6b de 4d 8a b2 68 2d
2d ce 2f fb f1 c1 3a 5b 05 8e 91 f7 83 e0 d2 07
2e 82 65 fb ed 54 6d 6a 15 f7 bc 6d 1f ee dd b0
fe 00 d5 2b cd 1c a0 66 0f c6 10 74 6c e0 33 a5
2b 58 fa be 0b 58 c5 8e 2f 75 88 24 6a 54 29 c5
ca 8a e9 c1 32 08 86 08 01 f8 ff 7e cc 47 d3 87
c6 26 22 67 5f 17 93 94 62 43 a3 fc 83 92 b4 48
02 ef 4f be 45 3a ee 73 fa 62 00 a7 91 2d 85 80
67 af 5e 24 d3 6d a5  

-----Sanity Check-----
We would expect the equation e*d mod lambda(n) == 1 and we can do so by using the python code below:

d = 3736994111495002080909763075762158191025953532441861446214530332409896424616989542177416161031443399891863916122047360277670225074909585617441661897890819358854269419219030807116533346697466622842133780814610182894963273241895064758313977881743185024515435092606000882111323756423951733253891134161795627917170353954652452595418045419252840025424901384922823961249110853796851268050480588001119237519538468673321405179822108284197056283057607576752772618380048822771085476983285101724007624269516313299129759141151232744282533264849951629272135932637336667827659340176043948817976925772347872360895937206092639835584688565519636488686985561547782222381388790381937004884788316353951971512906634962007729471694638048484108533734700149662474948664097204625566731209521189096407023503047076685827893857273241976521825038644748676708702908666544212935655266250636792506152215648477028264909271439159622871335425705478907075403113
p = 2364164709962113442171887272383487496579944095036359922875967042827855353288428852970005528391312406950479703131760653049027120352011623820866512389409477345856275579665550300038496403870769644284461617357689470541001176104885224312502189793178415245324848467558109125341820417143248504592923547378659642508887588391733764570518839040453363596044618121138052181633822405869902188801506763971935960892263903890470035750929450947730614255154431839010134096433230923
q = 1828007730310560470896068241648642314131393213229178258812812929993074796939313336843623671812684745127588474540181189375399367456782215444317753829482651728884736340320478712191506064873250441804382268919576910295309510863632743744023230090049499478279231712591216198432167465440053253466174344954467356186926045630005161328113250679664976135242227536137387753764404980268490656399307993738836541221314375289030653928495836484944225634658521613883043849390968783

if ((public_exponent * d) % ((p-1)*(q-1)) == 1) and (modulus == p*q):
    print("True")
else:
    print("False")

This python code checks both if the public_exponent (e) * d mod lambda(n) equals 1 and that p*q equals modulus. We were able to get all the variables from our public and private keys and this makes sense that these equations hold true and print true when this code is ran.

